# Роботу виконав студент ***Шроль Софія Григорівна***
> ***Київський політехнічний інституту, ІТС, група ТЗ-22***
## Lab7
- [x] Завдання: Переробити Lab7
### Опис
Виконати завдання лабораторної роботи №7, замінивши списки List (ArrayList та LinkedList) на множини Set (HashSet). Проаналізувати предметну область та на власний розсуд додати функціональність, для реалізації якої використати Map (TreeMap або HashMap).

> ***Контрольні питання:***

### 1. Чим інтерфейс Setвідрізняється від інтерфейсівCollection та List?

Collection — це базовий інтерфейс, який представляє загальну структуру для роботи з наборами об'єктів. Інтерфейс включає методи для додавання, видалення, перевірки наявності елементів тощо.
Set — це підінтерфейс Collection, який гарантує, що елементи в колекції є унікальними. В ньому не допускається дублювання елементів.
List — це інший підінтерфейс Collection, який дозволяє зберігати елементи в певному порядку. Дублікати дозволені, і кожен елемент має індекс.
Основна різниця між Set і List:

У Set елементи унікальні, порядок не гарантується (за винятком LinkedHashSet і TreeSet).
У List елементи можуть дублюватися, і порядок зберігається.


### 2. HashSet відрізняється від TreeSet?

HashSet:

Базується на хеш-таблиці.
Не гарантує порядок елементів.
Виконує операції додавання, видалення, пошуку за O(1) в середньому випадку.
Не підтримує сортування.
TreeSet:

Базується на червонно-чорному дереві.
Зберігає елементи в відсортованому порядку.
Виконує операції додавання, видалення, пошуку за O(log n).
Підтримує методи, які дозволяють працювати з піддіапазонами значень (subSet, headSet, tailSet).


### 3. Що таке хешування, хеш, хеш-код, хеш-функція?

- Хешування — це процес перетворення даних будь-якого розміру в фіксовану довжину (хеш-код) за допомогою хеш-функції.
- Хеш-код — це числове представлення об'єкта, яке генерується хеш-функцією.
- Хеш — це результат хешування, унікальний або майже унікальний ідентифікатор для об'єкта.
- Хеш-функція — це алгоритм, який перетворює вхідні дані в хеш-код.

### 4. Яким вимогам має відповідати коректна хеш-функція?

Для однакових об'єктів метод hashCode() повинен повертати однаковий результат.
Для різних об'єктів бажано повертати різні значення.
Результат повинен залишатися сталим протягом життєвого циклу об'єкта (якщо об'єкт не змінюється).


### 5. Які властивості притаманні хорошій хеш-функції?

- Рівномірність: Хеш-коди розподіляються рівномірно, щоб уникати кластерів.
- Швидкість: Хеш-код обчислюється швидко.
- Стабільність: Хеш-код не змінюється, поки об'єкт не зміниться.
- Мінімізація колізій: Мінімізує випадки, коли різні об'єкти мають однаковий хеш-код.

### 6. Якими критеріям мають відповідати об’єкти для того, щоб посилання на них можна було зберігати у HashSet?

Коректна імплементація методів hashCode() та equals().
Хеш-код має бути стабільним протягом існування об'єкта.
equals() має бути узгодженим з hashCode(): якщо два об'єкти рівні (equals() == true), вони повинні мати однаковий хеш-код.

### 7. Які є переваги/недоліки використання HashSetу порівнянні з TreeSet?

- Переваги HashSet:

Швидше виконує операції додавання, видалення та перевірки наявності.

Менші витрати пам'яті, якщо не враховувати колізії.

- Недоліки HashSet:

Не гарантує порядок елементів.

Відсутня підтримка сортування.

- Переваги TreeSet:

Зберігає елементи у відсортованому порядку.

Можна працювати з підмножинами даних.

- Недоліки TreeSet:

Більші витрати на пам'ять.

Повільніше виконує операції (через складність O(log n)).

### 8. Чим поняття sizeвідрізняється від capacity? Чи може sizeбути більший за capacity? Чи може capacityбути більший за size?Якщо так, то за яких умов?

- size — кількість елементів у колекції.

- capacity — максимальна кількість елементів, які можуть бути збережені без розширення внутрішньої структури.

- size не може бути більшим за capacity.

- capacity може бути більшим за size, наприклад, у масивах чи динамічних структурах (ArrayList).

### 9. Що таке load factorта на що і як він впливає?

Load factor — це відношення size до capacity (наприклад, 0.75 означає, що при заповненні 75% ємності відбувається розширення).
Вплив:
Вищий load factor зменшує кількість розширень, але збільшує кількість колізій.
Нижчий load factor зменшує колізії, але використовує більше пам'яті.


### 10. Що таке асоціативний масив? Чим ключ відрізняється від значення?

- Асоціативний масив — це структура даних (наприклад, HashMap), яка зберігає пари "ключ-значення".
- Ключ — це унікальний ідентифікатор, який використовується для доступу до значення.
- Значення — це дані, що зберігаються та асоціюються з ключем.

### 11. Чи може в асоціативному масиві зберігатись кілька однакових ключів або однакових значень?

- Однакові ключі — ні, ключі повинні бути унікальними.
- Однакові значення — так, значення можуть повторюватися.

### 12. До яких наслідків може привести зберігання неімутабельних об’єктів у HashSet, у HashMapв якості ключа та у HashMapв якості значення?

Відсутність коректної імплементації hashCode() і equals() може призвести до неправильного визначення унікальності об'єктів, що викликає некоректну роботу.

### 13. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у TreeMap?

Ні, TreeMap вимагає, щоб об'єкти були Comparable або щоб TreeMap було створено з власним Comparator.

### 14. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у HashMap? Чи взагалі впливає на щось наявність у об’єктів інтерфейсу Comparable при зберіганні у HashMap?

Так, Comparable не потрібен у HashMap, оскільки вона базується на хешуванні. Comparable впливає лише на сортування, яке не використовується у HashMap.